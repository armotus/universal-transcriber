"use strict";
function Transcribe(texts,rules) {
	texts = texts.toString();
	rules = rules.toString();
	let char1 = rules.charAt(0);
	let char2 = rules.charAt(1);
	if ( char1 === char2 ) { return ["Error in : char1 = char2 ( " + char2 + char2 + " )",rules]; };
	rules = rules.slice(1);
	rules = rules.slice(1);
	let aux1 = "\\";
	let aux2 = "\\";
	let aux3 = "\\";
	let regex = /[a-z A-Z 0-9]/;
	if ( regex.test(char1) ) { aux1 = "" };
	if ( regex.test(char2) ) { aux2 = "" };
	let char01 = new RegExp("("+aux1+char1+aux2+char2+"+)","g");
	let char02 = char1+char2;
	let char03 = new RegExp("("+aux2+char2+aux1+char1+"+)","g");
	let char04 = char2;
	let char05 = new RegExp(aux1+char1+"{2,}","g");
	let char06 = char1;
	let char07 = new RegExp(aux2+char2+"{2,}","g");
	let char08 = char2;
	let char0A = new RegExp("^"+aux1+char1,"g");
	let char0B = new RegExp("^"+aux2+char2,"g");
	rules = rules.replace(char01,char02).replace(char03,char04).replace(char05,char06).replace(char07,char08).replace(char0A,"").replace(char0B,"");
	let ListB = rules.split(char2);
	let positionB = 0;
	while ( ListB[positionB] ) {
		let char3 = new RegExp("[^"+aux1+char1+"]","g");
		if ( ListB[positionB].replace(char3,"").length !== 1 ) { return ["Error in : " + ListB[positionB],char1 + char2 + rules]; };
		let position = ListB[positionB].indexOf(char1, 0);
		let result1 = ListB[positionB].substring(0, position);
		let result2 = ListB[positionB].substring(position + 1, ListB[positionB].length);
		if ( result2 == "." ) { result2 = "\."};
		if ( regex.test(result1) ) { aux3 = "" };
		let myReplace1 = new RegExp(aux3+result1, "g");
		texts = texts.replace(myReplace1,result2);
		positionB = positionB + 1;
	};
	rules = char1 + char2 + rules;
	return [texts, rules];
};
// module.exports = { Transcribe };